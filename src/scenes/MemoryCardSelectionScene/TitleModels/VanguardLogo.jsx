/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.2 vanguard_logo.glb
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import { MathUtils } from 'three';

const MARGIN = .035; // `lerp` doesn't go up to the exact value so stop a little bit prior to target

export function VanguardLogo({ shouldRotate, getRef, animationCallback, targetScale, ...props }) {
  const ref = useRef();

  const [isComponentMounted, setIsComponentMounted] = useState(false);
  const [isLoadingAnimationFinished, setIsLoadingAnimationFinished] = useState(null);

  useFrame(({ clock }) => {
    if (shouldRotate) {
      const t = clock.getElapsedTime()
      ref.current.rotation.z = t
    }

    if (isLoadingAnimationFinished === false) {
      if (ref.current.scale.x <= targetScale - MARGIN) {
        const lerpValue = MathUtils.lerp(ref.current.scale.x, targetScale, 0.01)
        ref.current.scale.set(lerpValue, lerpValue, lerpValue)
      } else {
        if(animationCallback) animationCallback(); // tell parent component animation is finished
        setIsLoadingAnimationFinished(true);
      }
    }

    //TODO: shrinking animation. Might have to refactor to forwardRefs instead so that ObjectSelector can be the component that handles state changes
  })

  const startLoadingAnimation = async () => {
    setIsLoadingAnimationFinished(false);
  }

  useEffect(() => {
    if (!isComponentMounted && getRef) {
      getRef(ref);

      setIsComponentMounted(true);
    }
  }, [])

  const { nodes, materials } = useGLTF("models/vanguard_logo.glb")

  return (
    <group
      ref={ref}
      rotation-x={3.7}
      dispose={null}
      scale={0}
      {...props}
      startLoadingAnimation={() => startLoadingAnimation()}
    >
      <mesh geometry={nodes.Cube.geometry} material={materials.Material} />
    </group>
  )
}

useGLTF.preload('models/vanguard_logo.glb')
